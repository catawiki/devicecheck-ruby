# frozen_string_literal: true

# Copyright 2024 Catawiki B.V.
#
# Licensed under the MIT License (the "License");
#
# you may not use this file except in compliance with the License.
#
# You may obtain a copy of the License at
#
#     https://opensource.org/licenses/MIT
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require 'base64'
require 'cbor'
require 'json'
require 'openssl'
require 'securerandom'

module Devicecheck
  class Attestation
    ##
    # AAGUID for development environments
    AAGUID_DEVELOPMENT = 'appattestdevelop'
    # AAGUID for production environments
    AAGUID_PRODUCTION = "appattest\0\0\0\0\0\0\0"

    #
    # Initialize the attestation service by providing your app ID and
    # which environment are you testing.
    #
    # @param app_id [String] your App ID
    # @param environment [Symbol] `:production` or `:development`
    def initialize(app_id:, environment:)
      @app_id = app_id
      @environment = environment
      @sha256 = OpenSSL::Digest.new('SHA256')
    end

    #
    # Verifies the attestation generated by DCAppAttestService.  All
    # Base64 encoded strings should be sent in strict format (RFC 4648).
    #
    # @param key_id [String] Base64-encoded format of the public key ID
    # @param attestation_object [String] Base64-encoded of the
    #  attestation object generated by the `attestKey` method of
    #  `DCAppAttestService`
    # @param challenge [String] challenge originally provided by the server
    # @return [Array] An array containing:
    #   - the verified public key in DER format
    #   - the receipt from the attestation statement, which can be used
    #     later to request a fraud assessment metric from Apple.
    #
    #   If the key cannot be verified, a runtime error will be raised
    #   containing details about the failed check.
    def attest(key_id:, attestation_object:, challenge:)
      decoded_attestation_object = CBOR.decode(Base64.strict_decode64(attestation_object))

      att_stmt = decoded_attestation_object['attStmt']
      auth_data = decoded_attestation_object['authData']

      cred_cert = validate_certificates! att_stmt

      validate_challenge! challenge, auth_data, cred_cert
      validate_key_id! key_id, cred_cert
      validate_auth_data! key_id, auth_data

      [cred_cert.public_key.to_der, att_stmt['receipt']]
    end

    private

    attr_reader :app_id, :environment, :sha256

    def validate_certificates!(att_stmt)
      cred_cert = Validators::CertificateChainValidator.validate(att_stmt)

      raise 'Failed certificate chain check' unless cred_cert

      cred_cert
    end

    def validate_challenge!(challenge, auth_data, cred_cert)
      client_data_hash = sha256.digest(challenge)

      sequence = OpenSSL::ASN1.decode(cred_cert.find_extension('1.2.840.113635.100.8.2').value_der)

      unless valid_sequence?(sequence) &&
             sequence.value[0].value[0].value ==
             sha256.digest(auth_data + client_data_hash)
        raise 'Failed challenge check'
      end
    end

    def valid_sequence?(sequence)
      sequence.tag == OpenSSL::ASN1::SEQUENCE &&
        sequence.value.size == 1
    end

    def validate_key_id!(key_id, cred_cert)
      uncompressed_point_key = cred_cert.public_key.public_key.to_octet_string(:uncompressed)

      return if key_id == Base64.strict_encode64(sha256.digest(uncompressed_point_key))

      raise 'Failed key ID check'
    end

    def validate_auth_data!(key_id, auth_data)
      (rp_id_hash, _, sign_count, aaguid, credential_id) = Data::AuthenticatorData.unpack(auth_data)

      raise 'Failed RP ID check' unless rp_id_hash == sha256.digest(app_id)
      raise 'Failed sign counter = 0 check' unless sign_count.zero?
      raise 'Failed AAGUID check' unless aaguid == expected_aaguid
      raise 'Failed credentialId check' unless key_id == Base64.strict_encode64(credential_id)
    end

    def expected_aaguid
      case environment
      when :production
        AAGUID_PRODUCTION
      when :development
        AAGUID_DEVELOPMENT
      end
    end
  end
end
