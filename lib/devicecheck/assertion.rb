# frozen_string_literal: true

# Copyright 2024 Catawiki B.V.
#
# Licensed under the MIT License (the "License");
#
# you may not use this file except in compliance with the License.
#
# You may obtain a copy of the License at
#
#     https://opensource.org/licenses/MIT
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

module Devicecheck
  class Assertion
    # Initialize the assertion service by providing both the App ID
    # and the DER-encoded key that is associated with that App
    # instance that was previously saved after it was attested.
    def initialize(app_id:, pkey_der:)
      @app_id = app_id
      @pkey = OpenSSL::PKey.read(pkey_der)
      @sha256 = OpenSSL::Digest.new('SHA256')
    end

    # Verifies an assertion generated by the `generateAssertion`
    # method from DCAppAttestService.
    #
    # The app must obtain a one time unique value from the server,
    # which we will call `challenge`. Then, it will compute an
    # assertion by embedding this challenge into the `client_data`.
    #
    # For example, if `client_data` is:
    #
    # ```
    # { "new_score": 100 }
    # ```
    #
    # Then it must embed the challenge into this data, for example:
    #
    # ```
    # { "new_score": 100, "challenge": "..." }
    # ```
    #
    # Note that using JSON strings is just an example. It depends on
    # the use case and the interface must be established between the
    # mobile app and the server.  This is why we expect another
    # parameter (`client_data_challenge`) that contains the embedded
    # challenge value, since this library does not make any
    # assumption on the format or contents of `client_data`.
    #
    # @param client_data [String] client data (with embedded
    #  challenge)
    # @param client_data_challenge [String] client data challenge -
    #  copy of the challenge that is embedded in client data
    # @param assertion_object [String] Base64-encoded assertion
    #  object
    # @param expected_challenge [String] the challenge that was
    #  previously sent, to be compared with what was provided by the
    #  client
    # @param count [Integer] current assertion counter associated with
    #  this app - 0 if this is the first assertion
    #
    # @return [Integer] the authenticator `counter` value, to be stored for later use
    def assert(client_data:, client_data_challenge:, expected_challenge:, assertion_object:, count: 0)
      decoded_assertion_object = CBOR.decode(Base64.strict_decode64(assertion_object))

      signature = decoded_assertion_object['signature']
      authenticator_data = decoded_assertion_object['authenticatorData']

      (rp_id_hash, _, sign_count,) = Data::AuthenticatorData.unpack(authenticator_data)

      validate_signature!(signature, client_data, authenticator_data)

      validate_rp_id!(rp_id_hash)

      raise 'Failed count check' if sign_count < count
      raise 'Failed challenge check' unless client_data_challenge == expected_challenge

      sign_count
    end

    private

    attr_reader :app_id, :pkey, :sha256

    def validate_signature!(signature, client_data, authenticator_data)
      client_data_hash = sha256.digest(client_data)

      nonce = sha256.digest(authenticator_data + client_data_hash)

      raise 'Failed signature check' unless pkey.verify(sha256, signature, nonce)
    end

    def validate_rp_id!(rp_id_hash)
      raise 'Failed RP ID check' unless rp_id_hash == sha256.digest(app_id)
    end
  end
end
